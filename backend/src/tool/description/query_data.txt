使用 JMESPath 语法查询数据（Structured data in, structured data out），支持字段访问、数组投影、过滤与函数计算。

表格：{table_name}
{table_description}

参数：
- query (str, 必填): JMESPath 查询表达式（对 JSON 文档求值后返回 JSON）

### 0) 重要：默认避免“全量返回”
默认目标：**最小化返回内容**（只取必要字段 / 少量样本），避免把上下文淹没、序列化/传输变慢。

**除非任务明确需要全量，否则不要使用这些“高风险全量”写法（尤其当 json_path 指向根时）**：
- `@` / `*`：返回当前节点整体（可能等于整份数据）
- `[*]`：全量投影（可能返回数组全部元素）
- `foo[*]` / `items[*].bar`：不加限制也可能非常大

**安全默认工作流（推荐顺序）**：
1) 先用 `get_data_schema` 看结构（不含值），确认根节点类型与关键字段名
2) 用 `type(@)` / `length(@)` 自检，而不是直接取全量
3) 需要看样本：只取一个或小切片：`| [0]` / `[0:20]`
4) 只取必要字段（字段裁剪）：`users[?status=='active'].{id:id,name:name}`

### 1) 先搞清楚你在对什么做查询（根节点）
- 根节点就是整份 JSON 文档，可用 `@` 表示当前节点
- 但不要把 `@` 当“探路用的样本”：它会倾向返回整块数据；探路请用 `type(@)` / `length(@)` / `[0]` / `[0:20]`
- 根节点是 object：先写 `field` / `nested.field`
- 根节点是 array：可直接写 `[?...]`、`[*]`、`[0]`

常用自检（避免类型不匹配导致报错）：
- `type(@)`：返回 `"object"|"array"|"string"|"number"|"boolean"|"null"`
- `length(@)`：数组长度/字符串长度/对象键数（取决于实现；优先用来“快速确认不是空”）

### 2) 字段访问与标识符（最常见的“引号坑”）
- 访问字段：`field_name` 或 `nested.field`
- 如果字段名包含特殊字符/空格/连字符：用“双引号做 quoted identifier”
  - 例：`"user-name"`、`"a b"`、`"中文字段"`
  - 注意：双引号这里是“字段名”，不是字符串字面量

### 3) 字符串/字面量写法（避免比较报错）
- 字符串字面量用“单引号 raw string”：`'active'`、`'张三'`
  - 需要包含单引号时用反斜杠转义：`'can\'t'`
- JSON 字面量用“反引号 literal”：`` `{"a":1}` ``、`` `["x","y"]` ``、`` `true` ``、`` `null` ``
  - 反引号 literal 内必须是合法 JSON（反引号字符本身需要转义）

### 4) 数组与投影（`[*]` / `[]` / `[0]`）
- 投影（注意控制规模）：`items[*].name`（对 items 数组每个元素取 name；大数组请先切片 `items[0:20].name`）
- 展平一层数组：`items[].tags[]`（`[]` 是 flatten operator）
- 索引：`items[0]`、`items[-1]`（是否支持负索引取决于实现；不确定就别用）
- 切片：`items[0:10]`、`items[0:10:2]`

### 5) 过滤（`[? ... ]`）——只能用于数组
过滤表达式语法：`arrayField[? <条件表达式> ]`

关键限制（最容易引发 “JMESPath 出错”）：
- `[?...]` 只能作用在数组上；对 object / string / null 过滤会报错
- 所以对象根节点要先定位到数组字段：`users[?age > `20`].name`

比较运算符：
- 相等/不等：`==`、`!=`
- 大小：`<`、`<=`、`>`、`>=`

条件示例：
- 字符串：`users[?status=='active']`
- 布尔：`users[?active==true]`
- 数字：`users[?age>=`18`]`
- 组合条件：`users[?active==true && age>=`18`]`
- 否定：`users[?!(active==true)]`

### 6) 管道 `|`（解决“投影传播导致结果怪/索引报错”）
管道会把左侧结果作为右侧输入，并且**会停止左侧投影继续传播**，常用于：
- 先投影出数组，再只取第一个元素：`users[?active==true] | [0]`
- 先取字段再索引：`users | [0].name`

对比（理解这个差异能避免大量错误）：
- `foo[*].bar[0]`：会对每个元素的 bar 取 `[0]`（投影传播）
- `foo[*].bar | [0]`：先得到 `foo[*].bar` 的整体结果，再取第一个元素（不再对每个元素传播）

### 7) 常用函数（用来“容错/类型修正”，减少运行时报错）
- `to_array(x)`：把任何值变成数组（本身是数组则原样返回）
- `to_number(x)`：字符串数字转 number；非可转换类型返回 null
- `to_string(x)`：转字符串（对象/数组会 JSON 编码）
- `not_null(a,b,...)`：返回第一个非 null

### 8) 直接可复制的模板（按数据形状选）
1) 根节点是对象，数组字段叫 users：
- 过滤后取姓名列表：`users[?status=='active'].name`
- 先过滤再取第一个：`users[?status=='active'] | [0]`
- 取第一个人的 name（无过滤）：`users | [0].name`

2) 根节点是数组（元素是对象）：
- 找 id==1：`[?id==`1`]`
- 找到后取第一个：`[?id==`1`] | [0]`
- 只取 name（默认先限量）：`[0:20].name`

3) 字段名包含特殊字符：
- 例如字段 `user-name`：`"user-name"`
- 例如 `users` 里取 `user-name`：`users[*]."user-name"`

### 9) 排错清单（Agent 调用前自检）
- 过滤前确认是数组：不要写 `obj[?...]`，要写 `obj.arrayField[?...]`
- 字段名用双引号、字符串常量用单引号：不要混用
- 比较数字用 JSON literal：`age >= `18``（不要写 `age>18` 但把 18 写成字符串）
- 需要“整体取第一个/阻止投影传播”时加 `| [0]`

### 10) 低风险“探路”模板（优先用这些）
- 只确认类型：`type(@)`
- 只确认是否为空/大致规模：`length(@)`
- 根节点是数组：只看第 1 个：`[0]`
- 根节点是数组：只看前 20 个：`[0:20]`
- 根节点是对象：只看某个字段：`someField`
- 先定位到数组再取样本：`users | [0]`
- 先过滤再取样本：`users[?status=='active'] | [0]`
