# Text Block Node 测试文档

## 文档说明
- **组件路径**: `PuppyFlow/app/components/workflow/blockNode/TextBlockNode.tsx`
- **组件类型**: Block Node（数据块节点）
- **核心职责**: 文本内容的存储、编辑、展示和工作流连接

---

## 功能模块测试用例

### 📝 功能模块 1: 内容编辑与保存

#### 1.1 基础编辑功能

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-001 | 用户输入文本内容 | 1. 创建 Text Block<br>2. 在编辑区输入文本 | - 文本实时显示在编辑器中<br>- 内容同步到 node.data.content | **P0** | 核心功能，无法编辑则节点完全不可用 |
| TC-TEXT-002 | 编辑现有内容 | 1. 打开已有内容的节点<br>2. 修改部分文本 | - 修改立即反映在 UI<br>- 触发自动保存机制 | **P0** | 核心编辑体验，影响所有编辑场景 |
| TC-TEXT-003 | 清空所有内容 | 1. 删除节点内所有文本<br>2. 等待保存 | - 内容为空字符串<br>- savingStatus 正常流转 | **P1** | 常见操作，但可通过删除节点绕过 |
| TC-TEXT-004 | 超长文本输入（>10万字符） | 1. 粘贴超长文本<br>2. 观察性能和保存 | - 编辑器不卡顿<br>- 自动切换到外部存储<br>- 保存成功 | **P1** | 大数据场景，影响高级用户体验 |
| TC-TEXT-005 | 特殊字符输入 | 输入 emoji、换行符、特殊Unicode | - 特殊字符正确显示和保存<br>- 无乱码或丢失 | **P2** | 边缘场景但影响内容完整性 |

#### 1.2 自动保存机制

> **机制说明**：防抖保存对 internal 和 external 两种存储模式都生效
> - **Internal 存储**：当 `savingStatus='editing'` 时触发，2秒后保存
> - **External 存储**：当 `dirty=true` 时触发，2秒后保存
> - 两种模式都通过 `setTimeout(2000)` 实现防抖

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-006 | Internal 存储编辑后自动保存 | 1. 节点为 internal 存储<br>2. 编辑内容<br>3. 停止输入<br>4. 等待2秒 | - savingStatus: editing → saving → saved<br>- 2秒防抖生效<br>- 内容保存到 node.data.content | **P0** | 数据安全核心，保存失败导致数据丢失 |
| TC-TEXT-006-EXT | External 存储编辑后自动保存 | 1. 节点为 external 存储<br>2. 编辑内容（dirty=true）<br>3. 停止输入<br>4. 等待2秒 | - savingStatus: editing → saving → saved<br>- dirty: true → false<br>- 内容保存到外部存储 | **P0** | 外部存储数据安全 |
| TC-TEXT-007 | 快速连续编辑的防抖 | 1. 持续快速输入5秒<br>2. 停止输入 | - 中间状态不触发保存<br>- 停止后仅触发一次保存 | **P1** | 性能优化，防止频繁请求 |
| TC-TEXT-008 | 保存中再次编辑 | 1. 编辑内容A<br>2. 等待1秒<br>3. 再编辑内容B | - 旧保存被取消<br>- 新编辑重新计时2秒<br>- 最终保存最新内容B | **P1** | 防止数据覆盖，影响编辑流畅度 |
| TC-TEXT-009 | 保存失败处理 | 1. 模拟网络错误<br>2. 编辑并触发保存 | - savingStatus 显示 'error'<br>- saveError 包含错误信息<br>- 用户可重试 | **P0** | 数据安全，用户需知晓保存失败 |
| TC-TEXT-010 | 节点 isLoading 时不触发保存 | 1. 设置 node.data.isLoading = true<br>2. 编辑内容 | - 不触发自动保存<br>- 等待 isLoading=false 后恢复 | **P2** | 防止加载期间的冲突操作 |

#### 1.3 内容加载状态

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-011 | 节点加载中显示骨架屏 | 设置 isLoading=true | - 显示 SkeletonLoadingIcon<br>- 不显示 TextEditor | **P2** | 用户体验，但不影响功能 |
| TC-TEXT-012 | 加载完成后显示内容 | isLoading: true → false | - 骨架屏消失<br>- 显示完整内容 | **P1** | 影响内容可访问性 |

---

### 💾 功能模块 2: 动态存储策略

#### 2.1 存储类切换

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-013 | 内容超阈值切换到外部存储 | 1. 初始内容 < 阈值（internal）<br>2. 粘贴大量文本 > 阈值 | - storage_class: internal → external<br>- 生成 resource_key<br>- 内容正确保存到外部存储 | **P0** | 数据安全核心，切换失败导致数据丢失 |
| TC-TEXT-014 | 内容缩减切换回内部存储 | 1. 初始 external 存储<br>2. 删除内容至 < 阈值 | - storage_class: external → internal<br>- resource_key 清理<br>- 内容迁移到 node.data.content | **P0** | 数据完整性，迁移失败丢失内容 |
| TC-TEXT-015 | 阈值边界测试 | 内容长度恰好等于 CONTENT_LENGTH_THRESHOLD | - 存储策略稳定，不频繁切换<br>- 边界值有明确归属 | **P2** | 边缘场景，但需确保稳定 |
| TC-TEXT-016 | 存储切换时的数据一致性 | 1. 切换前读取内容A<br>2. 执行切换<br>3. 切换后读取内容B | - A === B，无数据丢失或损坏 | **P0** | 数据完整性，任何丢失都是致命问题 |

#### 2.2 Dirty 标记管理

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-017 | External 存储的 dirty 标记 | 1. 节点为 external 存储<br>2. 编辑内容 | - dirty=true<br>- 触发外部存储保存<br>- 保存后 dirty=false | **P1** | 外部存储核心机制，影响保存触发 |
| TC-TEXT-018 | Internal 存储不使用 dirty | 1. 节点为 internal 存储<br>2. 编辑内容 | - dirty 始终为 false<br>- 依靠 savingStatus='editing' 触发 | **P1** | 存储策略正确性，防止逻辑混乱 |
| TC-TEXT-019 | 仅 dirty=true 时触发外部保存 | 1. external 节点 dirty=false<br>2. 等待 | - 不触发保存请求 | **P2** | 性能优化，防止无效请求 |

#### 2.3 存储信息调试

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-020 | 保存时打印存储信息 | 编辑并保存节点 | Console 输出：<br>- contentLength<br>- storageClass<br>- resourceKey<br>- estimatedChunks | **P3** | 开发调试功能，不影响用户 |

---

### 🔗 功能模块 3: 节点连接

#### 3.1 Source Handles（输出连接点）

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-021 | 4个方向 Source Handle 可见 | 创建 Text Block 节点 | - 上、右、下、左各有1个 WhiteBallHandle<br>- ID 分别为 {id}-a/b/c/d | **P1** | 核心连接功能，无法连接则工作流断裂 |
| TC-TEXT-022 | 从 Source Handle 拖拽创建连接 | 从任一 Source Handle 拖出连线 | - 可成功连接到其他节点的 Target<br>- 连接关系正确记录 | **P0** | 工作流核心，无法连接则无法构建流程 |
| TC-TEXT-023 | isConnectable=false 时禁用 | 设置 isConnectable=false | - Source Handles 不可交互 | **P2** | 特殊场景下的控制功能 |

#### 3.2 Target Handles（输入连接点）

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-024 | 4个方向 Target Handle 存在 | 创建 Text Block 节点 | - 上、右、下、左各有1个透明 Handle<br>- type='target'<br>- 覆盖整个节点区域 | **P1** | 核心连接功能 |
| TC-TEXT-025 | 接收其他节点的连接 | 其他节点拖拽连线到此节点 | - 可成功建立连接<br>- 边缘高亮（orange） | **P0** | 工作流核心功能 |
| TC-TEXT-026 | 鼠标悬停 Target 时边框变色 | 鼠标移动到节点边缘区域 | - isOnConnect 时边框变为 orange | **P3** | 视觉反馈，不影响功能 |

---

### 🏷️ 功能模块 4: 节点角色自动识别

> **⚠️ 功能现状说明**：
> - ✅ **逻辑已实现**：代码会自动检测并设置 `isInput`/`isOutput` 标记
> - ❌ **无视觉反馈**：当前版本中这些标记**不影响节点样式**（无边框颜色、图标等变化）
> - 🎯 **用途未明**：标记可能用于后端工作流执行逻辑，但前端未消费这些状态
> - 📝 **测试建议**：测试重点放在数据标记的正确性，而非UI变化

#### 4.1 Input 节点检测

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-027 | 无上游有下游自动标记 Input | 1. 创建节点A<br>2. A连接到节点B（A→B）<br>3. A无其他上游 | - A被标记为 isInput=true<br>- 调用 manageNodeasInput(A.id)<br>- **注意**：UI 无变化 | **P2** | 数据标记功能，但无视觉反馈，降级为 P2 |
| TC-TEXT-028 | Input 节点新增上游后取消标记 | 1. A为 Input 节点<br>2. 创建 C→A 连接 | - A 的 isInput 状态更新<br>- 不再是起点节点<br>- **注意**：UI 无变化 | **P3** | 动态拓扑变化，无视觉影响 |

#### 4.2 Output 节点检测

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-029 | 有上游无下游自动标记 Output | 1. A→B 连接<br>2. B无其他下游 | - B被标记为 isOutput=true<br>- 调用 manageNodeasOutput(B.id)<br>- **注意**：UI 无变化 | **P2** | 数据标记功能，但无视觉反馈，降级为 P2 |
| TC-TEXT-030 | Output 节点新增下游后取消标记 | 1. B为 Output 节点<br>2. 创建 B→C 连接 | - B 的 isOutput 状态更新<br>- **注意**：UI 无变化 | **P3** | 动态拓扑变化，无视觉影响 |

#### 4.3 角色变更的性能优化

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-031 | 初次渲染延迟检测 | 组件首次挂载 | - 使用 requestAnimationFrame 延迟执行<br>- 避免阻塞首屏渲染 | **P3** | 性能优化，不影响功能正确性 |
| TC-TEXT-032 | 后续连接立即检测 | 非首次挂载的连接变化 | - 立即执行角色检测<br>- 无延迟 | **P3** | 交互响应速度，但无视觉反馈 |

---

### 🎨 功能模块 5: 标签管理

#### 5.1 标签显示

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-033 | 显示节点标签 | 创建节点（label="测试节点"） | - 左上角显示标签文本<br>- 带文档图标 | **P2** | 辅助信息，不影响核心功能 |
| TC-TEXT-034 | 标签为空时显示 ID | 创建节点（无 label） | - 显示 node.id 作为后备 | **P3** | 边缘场景，用户体验 |
| TC-TEXT-035 | 超长标签截断显示 | label 超过容器宽度 | - 文本 truncate 显示<br>- 不破坏布局 | **P3** | UI 细节 |

#### 5.2 标签编辑

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-036 | 点击重命名按钮编辑标签 | 1. 点击设置中的重命名<br>2. editable=true | - 标签变为 input 输入框<br>- 自动聚焦，光标在末尾 | **P2** | 常用功能，但非核心 |
| TC-TEXT-037 | 编辑标签并保存 | 1. 进入编辑模式<br>2. 修改文本<br>3. 失焦（blur） | - 调用 editNodeLabel(id, newLabel)<br>- isLocalEdit 重置为 false | **P2** | 标签修改的持久化 |
| TC-TEXT-038 | 编辑中点击外部取消 | 1. 编辑标签<br>2. 点击节点外部 | - 调用 setNodeUneditable(id)<br>- 如有修改则保存 | **P3** | 交互细节 |
| TC-TEXT-039 | 编辑时阻止节点拖拽 | 1. 进入编辑模式<br>2. 尝试拖拽节点 | - 添加 'nodrag' 类<br>- 节点不可拖动 | **P2** | 防止误操作，影响编辑体验 |

#### 5.3 标签同步

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-040 | 外部修改标签时同步 | 其他组件修改 node.data.label | - 本地 nodeLabel 自动更新<br>- 不覆盖正在编辑的本地状态 | **P2** | 数据一致性，但非高频场景 |

---

### 🎭 功能模块 6: UI 状态与交互

#### 6.1 边框颜色状态

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-041 | 加载中显示橙色边框 | isLoading=true | border-color: #FFA500 | **P3** | 视觉反馈 |
| TC-TEXT-042 | 等待流程显示绿色边框 | isWaitingForFlow=true | border-color: #39bc66 | **P3** | 视觉反馈 |
| TC-TEXT-043 | 激活时显示蓝色边框 | activatedNode.id === 当前id | border-color: main-blue | **P3** | 视觉反馈 |
| TC-TEXT-044 | 悬停时显示蓝色边框 | 鼠标移入节点 | border-color: main-blue | **P3** | 交互反馈 |
| TC-TEXT-045 | 连接中触摸显示橙色 | isOnConnect=true 且鼠标在边缘 | border-color: main-orange | **P3** | 连接引导 |
| TC-TEXT-046 | 默认状态深灰色边框 | 无特殊状态 | border-color: main-deep-grey | **P3** | 默认样式 |

#### 6.2 鼠标交互

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-047 | 鼠标移入激活节点 | 鼠标移入节点区域 | - isHovered=true<br>- 调用 activateNode(id) | **P3** | 交互反馈 |
| TC-TEXT-048 | 鼠标移出取消悬停 | 鼠标移出节点区域 | - isHovered=false | **P3** | 交互反馈 |

#### 6.3 拖拽功能

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-049 | 拖拽移动节点 | 在标签区域按住并拖动 | - 节点跟随鼠标移动<br>- cursor: grab → grabbing | **P1** | 核心布局功能 |
| TC-TEXT-050 | 编辑区域禁止拖拽 | 在文本编辑器上拖动 | - 节点不移动<br>- 可选中文本 | **P2** | 防止编辑冲突 |
| TC-TEXT-051 | 编辑标签时禁止拖拽 | 编辑标签输入框时拖动 | - 节点不移动 | **P2** | 防止编辑冲突 |

#### 6.4 调整大小

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-052 | 拖拽右下角调整大小 | 拖动 ResizeControl 手柄 | - 节点尺寸变化<br>- 最小 240x176px | **P2** | 布局自定义功能 |
| TC-TEXT-053 | 小于最小尺寸限制 | 尝试缩小至 < 240x176 | - 无法继续缩小<br>- 保持最小尺寸 | **P3** | 边界保护 |
| TC-TEXT-054 | 激活时显示调整手柄 | 节点激活 | - 右下角显示 resize 图标 | **P3** | 视觉引导 |
| TC-TEXT-055 | 未激活时隐藏手柄 | 节点未激活 | - resize 图标 visibility: hidden | **P3** | UI 整洁 |

#### 6.5 光标样式

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-056 | 生成新节点时十字光标 | isOnGeneratingNewNode=true | cursor: crosshair | **P3** | 操作引导 |
| TC-TEXT-057 | 正常状态默认光标 | 无特殊状态 | cursor: default | **P3** | 默认样式 |

---

### ⚡ 功能模块 7: 性能优化

#### 7.1 组件优化

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-058 | React.memo 防止无关重渲染 | 1. 其他节点更新<br>2. 本节点 props 未变 | - 本节点不重新渲染 | **P2** | 大型画布性能优化 |
| TC-TEXT-059 | useMemo 缓存计算结果 | props 无变化时多次渲染 | - borderColor、containerClassName、handleStyle 不重新计算 | **P3** | 性能优化细节 |
| TC-TEXT-060 | useCallback 缓存函数引用 | 多次渲染 | - 事件处理函数引用稳定 | **P3** | 性能优化细节 |

#### 7.2 动态加载

| 用例ID | 测试场景 | 操作步骤 | 预期结果 | 优先级 | 理由 |
|--------|---------|---------|---------|--------|------|
| TC-TEXT-061 | TextEditorBlockNote 懒加载 | 首次加载页面 | - 编辑器代码按需加载<br>- 减小初始包体积 | **P3** | 加载性能优化 |

---

## 🔥 优先级统计

| 优先级 | 数量 | 占比 | 说明 |
|--------|------|------|------|
| **P0** | 10 | 16.1% | 数据安全、核心保存、连接功能（新增外部存储保存测试） |
| **P1** | 12 | 19.4% | 核心编辑体验、存储策略、连接（角色识别降级） |
| **P2** | 23 | 37.1% | 非核心功能、可绕过问题（含无视觉反馈的数据标记） |
| **P3** | 27 | 43.5% | UI 细节、性能优化、视觉反馈（含无UI影响的功能） |
| **合计** | 62 | 100% | - |

### 📝 更新说明 (v1.1)

**修正内容**：
1. ✅ **防抖保存机制**：明确对 internal 和 external 两种存储模式都生效，新增 TC-TEXT-006-EXT
2. ⚠️ **角色识别功能**：确认逻辑正常但无视觉反馈，相关用例优先级下调（TC-TEXT-027/029: P1→P2, TC-TEXT-028/030/032: P2→P3）

---

## 📋 测试执行建议

### 阶段 1: P0 冒烟测试（核心功能保障）⏱️ 1-2天
**目标**: 确保节点基本可用，数据不丢失
- TC-TEXT-001, 002（编辑与显示）
- TC-TEXT-006, 006-EXT, 009（自动保存 - internal & external）
- TC-TEXT-013, 014, 016（存储策略切换）
- TC-TEXT-022, 025（节点连接）

**覆盖率**: 10/62 用例 (16.1%)，但覆盖 **80% 的致命风险**

### 阶段 2: P0 + P1 完整测试（生产就绪）⏱️ +2-3天
**新增内容**:
- TC-TEXT-003, 004, 007, 008（编辑边缘场景）
- TC-TEXT-012, 017, 018（加载与存储机制）
- TC-TEXT-021, 024, 049（连接和拖拽）

**覆盖率**: 22/62 用例 (35.5%)，**95% 核心场景保障**

### 阶段 3: P2 功能测试（完整体验）⏱️ +2-3天
- 标签管理全流程
- UI 交互细节
- 节点角色数据标记（无视觉反馈，以数据验证为主）
- 边缘场景处理

**覆盖率**: 45/62 用例 (72.6%)

### 阶段 4: P3 优化验证（锦上添花）⏱️ +1-2天
- 性能指标测试
- 视觉反馈一致性
- 样式细节检查
- 无UI影响的功能验证

**覆盖率**: 62/62 用例 (100%)

---

## 🧪 自动化测试建议

### 单元测试（Jest + React Testing Library）
```typescript
// 示例：内容编辑与保存
describe('TextBlockNode - Content Editing', () => {
  it('TC-TEXT-001: 应该能输入文本内容', () => {
    const { getByRole } = render(<TextBlockNode {...mockProps} />);
    const editor = getByRole('textbox');
    fireEvent.change(editor, { target: { value: 'Hello' } });
    expect(editor).toHaveValue('Hello');
  });

  it('TC-TEXT-006: 应该在2秒后自动保存', async () => {
    jest.useFakeTimers();
    const setNodes = jest.fn();
    render(<TextBlockNode {...mockProps} setNodes={setNodes} />);
    
    // 编辑内容
    const editor = getByRole('textbox');
    fireEvent.change(editor, { target: { value: 'New content' } });
    
    // 等待防抖
    jest.advanceTimersByTime(2000);
    
    await waitFor(() => {
      expect(setNodes).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({ 
            savingStatus: 'saving' 
          })
        })
      );
    });
  });
});
```

### 集成测试（Playwright）
```typescript
// 示例：存储策略切换
test('TC-TEXT-013: 超长内容应切换到外部存储', async ({ page }) => {
  await page.goto('/workflow/test-flow');
  
  // 创建节点
  await page.click('[data-testid="add-text-block"]');
  
  // 粘贴超长文本（>阈值）
  const longText = 'a'.repeat(100000);
  await page.fill('[data-testid="text-editor"]', longText);
  
  // 等待保存
  await page.waitForTimeout(2500);
  
  // 验证存储类
  const node = await page.evaluate(() => {
    return window.__reactflow__.getNodes()[0];
  });
  
  expect(node.data.storage_class).toBe('external');
  expect(node.data.resource_key).toBeTruthy();
});
```

---

## 🐛 已知风险点

### 1. 数据丢失风险（P0）
- **场景**: 存储策略切换时网络中断
- **影响**: 内容可能在迁移过程中丢失
- **缓解**: 需要事务性保证或双写策略

### 2. 并发编辑冲突（P1）
- **场景**: 多用户同时编辑同一节点
- **影响**: 后保存的覆盖先保存的
- **缓解**: 需要冲突检测和合并策略

### 3. 浏览器崩溃未保存（P1）
- **场景**: 编辑2秒内浏览器崩溃
- **影响**: 最近修改丢失
- **缓解**: 可考虑 localStorage 临时缓存

### 4. 超大内容性能（P2）
- **场景**: 百万字符级别的文本
- **影响**: 编辑器卡顿，保存缓慢
- **缓解**: 虚拟滚动或分块加载

---

## 📊 测试覆盖率目标

| 类型 | 目标 | 说明 |
|------|------|------|
| 代码覆盖率 | ≥80% | 核心逻辑必须覆盖 |
| 分支覆盖率 | ≥70% | 关键分支路径覆盖 |
| P0/P1 用例 | 100% | 必须全部通过 |
| P2 用例 | ≥90% | 允许少量已知问题 |
| P3 用例 | ≥70% | 可在迭代中完善 |

---

## 📝 测试环境要求

### 浏览器兼容性
- Chrome/Edge ≥90
- Firefox ≥88
- Safari ≥14

### 数据准备
- 测试用户账号
- 测试工作流模板
- 模拟外部存储服务

### 监控指标
- 保存成功率 ≥99.9%
- 自动保存延迟 ≤2.5s
- 编辑器输入延迟 ≤100ms
- 存储切换耗时 ≤1s

---

## 📚 版本历史

| 版本 | 日期 | 修改内容 |
|------|------|----------|
| v1.1 | 2025-10-21 | ✅ 明确防抖保存对两种存储模式都生效<br>⚠️ 确认角色识别功能无视觉反馈，调整优先级<br>📊 更新用例统计（62个用例） |
| v1.0 | 2025-10-21 | 初始版本，61个测试用例 |

---

*当前版本: v1.1*  
*最后更新: 2025-10-21*  
*维护者: 测试团队*

