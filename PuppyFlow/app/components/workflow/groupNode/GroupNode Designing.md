# GroupNode 产品设计文档

## 1. 概述

GroupNode（组节点）是一个可视化的容器功能，允许用户将多个相关的工作流节点组织在一起，形成一个逻辑单元。这个单元可以作为一个整体进行测试、部署和管理，极大地提升了复杂工作流的组织效率。

## 2. 核心价值

### 2.1 为什么需要 GroupNode？
- **组织复杂工作流**：当工作流包含几十个节点时，通过分组让逻辑更清晰
- **模块化管理**：将相关功能封装成组，便于复用和维护
- **快速部署**：一键将组内工作流发布为 API 或聊天机器人
- **团队协作**：不同的组可以分配给不同的团队成员负责

### 2.2 支持的节点类型
组内可以包含以下类型的工作节点：
- **文本节点** - 处理纯文本内容
- **文件节点** - 处理各类文件和文档
- **网页节点** - 处理网页链接和内容
- **结构化节点** - 处理 JSON、表格等结构化数据

## 3. 用户界面设计

### 3.1 视觉外观

```
┌─────────────────────────────────────────────────┐
│ Group 1                              (2 nodes)  │  ← 组名称和节点数量
│ ┌─────────────────────────────────────────────┐ │
│ │                                             │ │
│ │         拖拽节点到这里                       │ │  ← 空白时的提示文字
│ │                                             │ │
│ │                                             │ │
│ └─────────────────────────────────────────────┘ │
│                                                 │
│ [🔄] [📤] [🗑️] | [🎨] [▶️ Test Run] [🚀 Deploy] │  ← 功能按钮
└─────────────────────────────────────────────────┘
```

#### 3.1.1 尺寸规格
- 最小尺寸：240px × 176px
- 可通过8个调整手柄自由调整大小
- 圆角设计，视觉更柔和

#### 3.1.2 颜色主题
提供8种预设背景色，帮助用户区分不同功能的组：
- **透明**（默认）- 通用组
- **灰色** - 数据处理组
- **棕色** - 文件操作组
- **红色** - 重要/警告组
- **绿色** - 成功/验证组
- **蓝色** - 信息处理组
- **紫色** - AI/创意组
- **粉色** - 特殊标记组

### 3.2 功能按钮说明

#### 3.2.1 操作按钮
- **🔄 重新计算**：自动重新排列组内节点，优化布局
- **📤 分离全部**：将所有节点从组中移出（保留节点）
- **🗑️ 删除**：删除整个组及其包含的所有节点

#### 3.2.2 功能按钮
- **🎨 背景色**：选择组的背景颜色
- **▶️ Test Run**：测试运行组内的完整工作流
- **🚀 Deploy**：将组部署为 API 或聊天机器人服务

### 3.3 交互操作

#### 3.3.1 节点管理操作
- **添加节点**：拖拽节点到组内区域即可加入
- **移除节点**：拖拽节点到组外即可移出
- **批量操作**：支持框选多个节点一起拖入

#### 3.3.2 调整大小
- 鼠标悬停在组边缘时显示调整手柄
- 支持从8个方向调整大小（四边 + 四角）
- 实时预览调整效果

## 4. 部署功能

### 4.1 部署选项

点击 Deploy 按钮后，用户可以选择两种部署方式：

#### 4.1.1 部署为 API
将组内工作流转换为可调用的 REST API 接口，适合系统集成场景。

#### 4.1.2 部署为聊天机器人
创建一个对话式交互界面，适合客服、问答等场景。

### 4.2 部署流程示意

```
用户操作流程：
1. 点击 Deploy 按钮
        ↓
2. 选择部署类型
   ┌─────────────────────┐
   │ • Deploy as API     │
   │ • Deploy as Chatbot │
   └─────────────────────┘
        ↓
3. 配置输入输出
   ┌─────────────────────┐
   │ 选择输入节点：       │
   │ ☑ 用户输入          │
   │ ☐ 配置文件          │
   │                     │
   │ 选择输出节点：       │
   │ ☐ 中间结果          │
   │ ☑ 最终报告          │
   └─────────────────────┘
        ↓
4. 点击确认部署
        ↓
5. 获得访问凭证
   ┌─────────────────────┐
   │ API ID: api_12345   │
   │ API Key: xxxxxx     │
   │ 端点: /api/12345    │
   └─────────────────────┘
```

### 4.3 已部署服务管理

系统会记录所有已部署的服务，方便管理：

```
┌──────────────────────────────────┐
│     已部署服务                    │
│                                  │
│ API 服务 (2)                     │
│ • 用户查询API     [查看] [删除]  │
│ • 数据处理API     [查看] [删除]  │
│                                  │
│ 聊天机器人 (1)                   │
│ • 客服机器人      [查看] [删除]  │
│                                  │
│ [+ 创建新部署]    [🔄 刷新]      │
└──────────────────────────────────┘
```

## 5. 工作流提交机制

### 5.1 智能识别机制

系统会智能识别哪些内容需要作为工作流的一部分提交执行。

### 5.2 复杂结构分析示例

以下是一个包含多种连接情况的复杂示例：

```
                组外节点                        组内节点                    组外节点
              ┌─────────┐                  ┌─────────────────────────────────────────────────┐
              │ Node_E  │                  │                Group                             │
              │ (外部)  │                  │                                                 │
              └─────────┘                  │  ┌─────────┐    Edge_1    ┌─────────┐          │
                   │                       │  │ Node_A  │ ──────────► │ Node_B  │          │
                   │ Edge_5                │  │ (text)  │              │ (struct)│          │
                   ▼                       │  └─────────┘              └─────────┘          │
              ┌─────────┐    Edge_6        │                                 │               │
              │ Node_F  │ ──────────────── │ ──────┐                        │ Edge_2        │
              │ (外部)  │                  │       ▼                        ▼               │
              └─────────┘                  │  ┌─────────┐    Edge_3    ┌─────────┐          │
                                          │  │ Node_C  │ ◄────────── │ Node_D  │          │
                                          │  │ (text)  │              │ (struct)│          │
                                          │  └─────────┘              └─────────┘          │
                                          │       │                                         │
                                          │       │ Edge_4                                  │
                                          │       ▼                                         │
                                          │  ┌─────────┐                                    │
                                          │  │ Node_G  │                                    │
                                          │  │ (file)  │                                    │
                                          │  └─────────┘                                    │
                                          └─────────────────────────────────────────────────┘
                                                    │ Edge_7
                                                    ▼
                                               ┌─────────┐
                                               │ Node_H  │
                                               │ (外部)  │
                                               └─────────┘
```

#### 5.2.1 Block 节点提交判断逻辑

**第一阶段：识别组内 Block 节点**
```
节点归属判断：
┌────────────┬──────────┬─────────────────────────────────────┐
│    节点    │   位置   │              判断逻辑               │
├────────────┼──────────┼─────────────────────────────────────┤
│  Node_A    │   组内   │ node.data.groupIds.includes(groupId) │
│  Node_B    │   组内   │ node.data.groupIds.includes(groupId) │
│  Node_C    │   组内   │ node.data.groupIds.includes(groupId) │
│  Node_D    │   组内   │ node.data.groupIds.includes(groupId) │
│  Node_G    │   组内   │ node.data.groupIds.includes(groupId) │
│  Node_E    │   组外   │ 不包含当前 groupId                   │
│  Node_F    │   组外   │ 不包含当前 groupId                   │
│  Node_H    │   组外   │ 不包含当前 groupId                   │
└────────────┴──────────┴─────────────────────────────────────┘

初步确定的组内 Block：Node_A, Node_B, Node_C, Node_D, Node_G
```

#### 5.2.2 Edge 连接分析与判断逻辑

**第二阶段：分析所有相关的 Edge 连接**
```
Edge 连接关系分析：
┌────────────┬─────────────────┬─────────────────┬──────────────────────┐
│    Edge    │     输入端      │     输出端      │       连接类型       │
├────────────┼─────────────────┼─────────────────┼──────────────────────┤
│  Edge_1    │ Node_A (组内)   │ Node_B (组内)   │    组内 → 组内       │
│  Edge_2    │ Node_B (组内)   │ Node_D (组内)   │    组内 → 组内       │
│  Edge_3    │ Node_D (组内)   │ Node_C (组内)   │    组内 → 组内       │
│  Edge_4    │ Node_C (组内)   │ Node_G (组内)   │    组内 → 组内       │
│  Edge_5    │ Node_E (组外)   │ Node_F (组外)   │    组外 → 组外       │
│  Edge_6    │ Node_F (组外)   │ Node_C (组内)   │    组外 → 组内       │
│  Edge_7    │ Node_G (组内)   │ Node_H (组外)   │    组内 → 组外       │
└────────────┴─────────────────┴─────────────────┴──────────────────────┘
```

**第三阶段：Edge 有效性判断（核心逻辑）**
```
Edge 提交判断规则（更新版）：
┌────────────┬─────────────────┬─────────────────┬─────────────┬──────────────────┐
│    Edge    │   输入端状态    │   输出端状态    │  判断结果   │    判断依据      │
├────────────┼─────────────────┼─────────────────┼─────────────┼──────────────────┤
│  Edge_1    │ ✅ 有组内节点   │ ✅ 有组内节点   │     ✅      │ 条件1：双端有组内│
│  Edge_2    │ ✅ 有组内节点   │ ✅ 有组内节点   │     ✅      │ 条件1：双端有组内│
│  Edge_3    │ ✅ 有组内节点   │ ✅ 有组内节点   │     ✅      │ 条件1：双端有组内│
│  Edge_4    │ ✅ 有组内节点   │ ✅ 有组内节点   │     ✅      │ 条件1：双端有组内│
│  Edge_5    │ ❌ 无组内节点   │ ❌ 无组内节点   │     ❌      │ 双端都在组外     │
│  Edge_6    │ ❌ 无组内节点   │ ✅ 有组内节点   │     ✅      │ 条件3：输出全组内│
│  Edge_7    │ ✅ 有组内节点   │ ❌ 无组内节点   │     ✅      │ 条件2：输入全组内│
└────────────┴─────────────────┴─────────────────┴─────────────┴──────────────────┘

判断规则详解（新规则）：
✅ 有效条件（满足其中一条即可）：
  条件1：输入端有组内节点 AND 输出端有组内节点
  条件2：输入端节点全部在组内 AND 输出端无组内节点
  条件3：输入端无组内节点 AND 输出端节点全部在组内

❌ 无效情况：
  输入端和输出端都没有组内节点

详细分析：
- Edge_6: Node_F(组外) → Node_C(组内) 
  输入端无组内节点，输出端全部是组内节点 ✅ 符合条件3
- Edge_7: Node_G(组内) → Node_H(组外)
  输入端全部是组内节点，输出端无组内节点 ✅ 符合条件2

有效的 Edge：Edge_1, Edge_2, Edge_3, Edge_4, Edge_6, Edge_7
无效的 Edge：Edge_5
```

#### 5.2.3 最终提交内容确定

**第四阶段：基于有效 Edge 确定最终的 Block 列表**
```
最终 Block 确定逻辑：
1. 从有效的 Edge 列表中收集所有相关的 Block 节点
2. Edge_1: Node_A, Node_B
3. Edge_2: Node_B, Node_D  
4. Edge_3: Node_D, Node_C
5. Edge_4: Node_C, Node_G
6. Edge_6: Node_F, Node_C  ← 新增：外部输入
7. Edge_7: Node_G, Node_H  ← 新增：外部输出

合并去重后的 Block 列表：Node_A, Node_B, Node_C, Node_D, Node_G, Node_F, Node_H
（包含了组内节点 + 相关的外部节点）
```

**提交到后端的最终 JSON 结构：**
```json
{
  "blocks": {
    "Node_A": { "type": "text", "data": {...} },
    "Node_B": { "type": "structured", "data": {...} },
    "Node_C": { "type": "text", "data": {...} },
    "Node_D": { "type": "structured", "data": {...} },
    "Node_G": { "type": "file", "data": {...} },
    "Node_F": { "type": "external", "data": {...} },
    "Node_H": { "type": "external", "data": {...} }
  },
  "edges": {
    "Edge_1": { "inputs": ["Node_A"], "outputs": ["Node_B"], "data": {...} },
    "Edge_2": { "inputs": ["Node_B"], "outputs": ["Node_D"], "data": {...} },
    "Edge_3": { "inputs": ["Node_D"], "outputs": ["Node_C"], "data": {...} },
    "Edge_4": { "inputs": ["Node_C"], "outputs": ["Node_G"], "data": {...} },
    "Edge_6": { "inputs": ["Node_F"], "outputs": ["Node_C"], "data": {...} },
    "Edge_7": { "inputs": ["Node_G"], "outputs": ["Node_H"], "data": {...} }
  }
}
```

**关键判断原则总结（更新版）：**
1. **Block 节点**：包含组内节点 + 通过有效 Edge 连接的外部节点
2. **Edge 连接**：满足以下条件之一即可提交
   - 输入端有组内节点 AND 输出端有组内节点
   - 输入端节点全部在组内 AND 输出端无组内节点（外部输出）
   - 输入端无组内节点 AND 输出端节点全部在组内（外部输入）
3. **扩展性**：允许外部节点作为组工作流的输入源或输出目标
4. **一致性检查**：所有提交的 Edge 的输入输出都在提交的 Block 列表中

**新规则的意义：**
- **外部输入支持**：外部数据源可以直接为组提供数据
- **外部输出支持**：组的处理结果可以直接输出到外部系统
- **更灵活的集成**：组不再是完全封闭的，可以与外部系统更好地集成

### 5.3 Edge 连接分析和判断逻辑

**所有 Edge 连接关系：**
- **Edge_1**: Node_A → Node_B （组内→组内）
- **Edge_2**: Node_B → Node_D （组内→组内）
- **Edge_3**: Node_D → Node_C （组内→组内）
- **Edge_4**: Node_C → Node_G （组内→组内）
- **Edge_5**: Node_E → Node_F （组外→组外）
- **Edge_6**: Node_F → Node_C （组外→组内）
- **Edge_7**: Node_G → Node_H （组内→组外）

**判断逻辑详解：**

```
Edge 有效性判断规则：
┌────────────┬─────────────┬─────────────┬─────────────┬──────────┐
│    Edge    │   输入端    │   输出端    │  判断结果   │   原因   │
├────────────┼─────────────┼─────────────┼─────────────┼──────────┤
│  Edge_1    │ Node_A(组内)│ Node_B(组内)│     ✅      │ 双端组内 │
│  Edge_2    │ Node_B(组内)│ Node_D(组内)│     ✅      │ 双端组内 │
│  Edge_3    │ Node_D(组内)│ Node_C(组内)│     ✅      │ 双端组内 │
│  Edge_4    │ Node_C(组内)│ Node_G(组内)│     ✅      │ 双端组内 │
│  Edge_5    │ Node_E(组外)│ Node_F(组外)│     ❌      │ 双端组外 │
│  Edge_6    │ Node_F(组外)│ Node_C(组内)│     ❌      │ 单端组内 │
│  Edge_7    │ Node_G(组内)│ Node_H(组外)│     ❌      │ 单端组内 │
└────────────┴─────────────┴─────────────┴─────────────┴──────────┘

有效的 Edge: Edge_1, Edge_2, Edge_3, Edge_4
无效的 Edge: Edge_5, Edge_6, Edge_7
```

**最终提交分析：**
由于有效的 Edge 只连接组内节点，所以最终提交的 Block 节点就是组内的所有节点：
- **提交的 Block**: Node_A, Node_B, Node_C, Node_D, Node_G
- **提交的 Edge**: Edge_1, Edge_2, Edge_3, Edge_4
- **形成链路**: Node_A → Node_B → Node_D → Node_C → Node_G

### 5.4 多输入多输出复杂场景

更复杂的场景：一个 Edge 连接多个输入和输出节点

```
                     组外节点                          组内节点
                  ┌─────────┐                  ┌─────────────────────────────────────────────────┐
                  │ Node_X  │                  │                                                 │
                  │ (外部)  │                  │        ┌─────────┐         ┌─────────┐        │
                  └─────────┘                  │        │ Node_A  │         │ Node_D  │        │
                       │                       │        │ (text)  │         │ (struct)│        │
                       │ Edge_8                │        └─────────┘         └─────────┘        │
                       ▼                       │              │                    ▲           │
                  ┌─────────┐                  │              │                    │           │
                  │ Node_Y  │                  │              ▼         Edge_11    │           │
                  │ (外部)  │────────────────  │ ─────► ┌──────────────────────────────┐       │
                  └─────────┘      Edge_9     │        │        Edge_10             │       │
                       │                       │        │   (多输入多输出处理)        │       │
                       │ Edge_12               │        └──────────────────────────────┘       │
                       ▼                       │              │                    ▲           │
                  ┌─────────┐                  │              │                    │           │
                  │ Node_Z  │                  │              ▼                    │           │
                  │ (外部)  │                  │        ┌─────────┐         ┌─────────┐        │
                  └─────────┘                  │        │ Node_B  │         │ Node_C  │        │
                                               │        │ (file)  │         │ (text)  │        │
                                               │        └─────────┘         └─────────┘        │
                                               │              │                                 │
                                               │              │ Edge_13                        │
                                               │              ▼                                 │
                                               │        ┌─────────┐                            │
                                               │        │ Node_E  │                            │
                                               │        │ (struct)│                            │
                                               │        └─────────┘                            │
                                               └─────────────────────────────────────────────────┘
                                                        │ Edge_14
                                                        ▼
                                                   ┌─────────┐
                                                   │ Node_W  │
                                                   │ (外部)  │
                                                   └─────────┘
```

**复杂 Edge 分析：**

```
多输入多输出的 Edge_10:
输入端：Node_A (组内), Node_Y (组外), Node_C (组内)
输出端：Node_B (组内), Node_D (组内)

判断规则：
1. 输入端至少有一个组内节点：Node_A ✅, Node_C ✅
2. 输出端至少有一个组内节点：Node_B ✅, Node_D ✅
结果：Edge_10 有效 ✅

其他 Edge 判断：
- Edge_8: Node_X(外) → Node_Y(外) ❌ (双端组外)
- Edge_9: Node_Y(外) → Edge_10 ❌ (外部输入，不参与判断)
- Edge_11: Edge_10 → Node_D(内) ❌ (外部输入，不参与判断)
- Edge_12: Node_Y(外) → Node_Z(外) ❌ (双端组外)
- Edge_13: Node_B(内) → Node_E(内) ✅ (双端组内)
- Edge_14: Node_E(内) → Node_W(外) ❌ (单端组内)
```

**最终提交结果：**
- **有效的 Edge**: Edge_10, Edge_13
- **提交的 Block**: Node_A, Node_B, Node_C, Node_D, Node_E
- **关键点**: 即使 Node_Y 是外部节点，但因为 Edge_10 满足"双端都有组内节点"的条件，所以这个 Edge 仍然有效

**这个例子说明了：**
1. 一个 Edge 可以有多个输入和输出
2. 只要输入端和输出端都至少有一个组内节点，Edge 就有效
3. 外部节点可能会因为有效的 Edge 而被间接"包含"在处理逻辑中

### 5.5 边界情况分析

#### 5.5.1 孤立节点的处理

```
┌─────────────────────────────────────────────────────────────┐
│                      Group                                   │
│                                                             │
│  ┌─────────┐    Edge_A    ┌─────────┐    Edge_B    ┌──────┐ │
│  │ Node_1  │ ──────────► │ Node_2  │ ──────────► │Node_3│ │
│  └─────────┘              └─────────┘              └──────┘ │
│                                                             │
│  ┌─────────┐              ┌─────────┐                      │
│  │ Node_4  │              │ Node_5  │  （孤立节点）         │
│  │(孤立节点)│              │(孤立节点)│                      │
│  └─────────┘              └─────────┘                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**分析结果：**
- Node_4 和 Node_5 没有任何 Edge 连接
- 根据提交逻辑，这些孤立节点**不会被提交**
- 只有 Node_1, Node_2, Node_3 和连接它们的 Edge_A, Edge_B 会被提交

#### 5.5.2 循环依赖的处理

```
组内循环结构：
┌─────────────────────────────────────────────────────────────┐
│                      Group                                   │
│                                                             │
│  ┌─────────┐    Edge_X    ┌─────────┐                      │
│  │ Node_A  │ ──────────► │ Node_B  │                      │
│  └─────────┘              └─────────┘                      │
│       ▲                        │                           │
│       │ Edge_Z                 │ Edge_Y                    │
│       │                        ▼                           │
│  ┌─────────┐    Edge_W    ┌─────────┐                      │
│  │ Node_D  │ ◄──────────  │ Node_C  │                      │
│  └─────────┘              └─────────┘                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘

形成循环：Node_A → Node_B → Node_C → Node_D → Node_A
```

**分析结果：**
- 所有 Edge (Edge_X, Edge_Y, Edge_W, Edge_Z) 都是双端组内 ✅
- 所有 Node (Node_A, Node_B, Node_C, Node_D) 都会被提交
- 循环依赖在提交时是允许的，由后端执行引擎处理

## 6. 业务场景应用

### 6.1 数据处理流水线

```
┌─────────────────────────────────────────┐
│            CSV数据清洗组                 │
│                                         │
│ 上传CSV → 数据验证 → 清洗规则 → 输出     │
│              ↓                          │
│         异常处理 → 错误报告              │
│                                         │
└─────────────────────────────────────────┘
```

### 6.2 AI内容生成工作流

```
┌─────────────────────────────────────────┐
│            AI内容创作组                  │
│                                         │
│ 主题输入 → AI生成 → 人工审核 → 发布     │
│              ↓                          │
│         关键词提取 → SEO优化             │
│                                         │
└─────────────────────────────────────────┘
```

### 6.3 智能客服系统

```
┌─────────────────────────────────────────┐
│            智能客服处理组                │
│                                         │
│ 用户问题 → 意图识别 → 知识检索 → 回答   │
│              ↓              ↓           │
│         情感分析 ────→ 人工转接判断       │
│                                         │
└─────────────────────────────────────────┘
```


### 6.4 文档智能分析

```
┌─────────────────────────────────────────┐
│            文档分析组                    │
│                                         │
│ 文档上传 → 格式识别 → 内容提取 → 摘要   │
│              ↓                          │
│         OCR识别 → 结构化存储 → 索引     │
│                                         │
└─────────────────────────────────────────┘
```

### 6.5 营销自动化流程

```
┌─────────────────────────────────────────┐
│            营销自动化组                  │
│                                         │
│ 用户行为 → 标签分析 → 内容推荐 → 推送   │
│              ↓          ↓               │
│         A/B测试 ────→ 效果统计 → 优化   │
│                                         │
└─────────────────────────────────────────┘
```

### 6.6 财务报表生成

```
┌─────────────────────────────────────────┐
│            财务报表组                    │
│                                         │
│ 原始数据 → 数据校验 → 计算处理 → 报表   │
│              ↓                          │
│         异常标记 → 人工审核 → 归档       │
│                                         │
└─────────────────────────────────────────┘
```

### 6.7 社交媒体监控

```
┌─────────────────────────────────────────┐
│            社媒监控组                    │
│                                         │
│ 内容抓取 → 情感分析 → 关键词筛选 → 报告 │
│              ↓          ↓               │
│         负面预警 ────→ 危机响应流程      │
│                                         │
└─────────────────────────────────────────┘
```

## 7. Test Run 功能

### 7.1 测试运行流程

当用户点击 "Test Run" 按钮时：

```
用户操作：点击 Test Run
        ↓
系统自动识别组内工作流
        ↓
┌─────────────────────────┐
│ 执行状态显示             │
│                         │
│ ✓ 数据验证    (完成)     │
│ ⏳ AI处理     (进行中)   │
│ ⏸ 格式整理    (等待)     │
│ ⏸ 结果输出    (等待)     │
│                         │
└─────────────────────────┘
        ↓
显示执行结果和用时
```

### 7.2 实时进度反馈

- **节点状态指示**：每个节点显示执行状态（等待/进行中/完成/错误）
- **进度条显示**：整体执行进度的可视化展示
- **日志信息**：详细的执行日志和调试信息
- **错误提示**：出现问题时的具体错误信息和建议

## 8. API 部署详细流程

### 8.1 部署流程图解

#### 8.1.1 完整的部署流程

```
用户操作流程：
┌───────────────┐
│ 点击 Deploy   │
│    按钮       │
└───────┬───────┘
        ▼
┌───────────────┐
│选择部署为 API │
└───────┬───────┘
        ▼
┌───────────────────────────────────────────┐
│         选择输入输出节点界面               │
│                                           │
│  Inputs:              Outputs:            │
│  ┌──────────┐        ┌──────────┐        │
│  │ □ Block A │        │ □ Block A │        │
│  │ ✓ Block B │        │ □ Block B │        │
│  │ □ Block C │        │ □ Block C │        │
│  │ □ Block D │        │ ✓ Block D │        │
│  └──────────┘        └──────────┘        │
│                                           │
│  只显示 text 和 structured 类型的节点      │
└───────────────────────────────────────────┘
        ▼
┌───────────────┐
│  点击 Deploy  │
│   as API      │
└───────┬───────┘
        ▼
```

#### 8.1.2 数据提交过程

```
假设用户选择：
- 输入: Block B
- 输出: Block D

提交的数据结构：
{
  "workflow_json": {
    "blocks": {
      "Block_B": { /* 完整的节点数据 */ },
      "Block_C": { /* 完整的节点数据 */ },
      "Block_D": { /* 完整的节点数据 */ },
      // 注意：即使 Block A 在组内，但因为没有有效的 EdgeNode 连接它，
      // 所以它不会被包含在提交的数据中
    },
    "edges": {
      "Edge_2": { /* C→B 的边数据 */ },
      "Edge_3": { /* B+C→D 的边数据 */ }
      // Edge 1 和 Edge 4 不满足条件，不会被提交
    }
  },
  "inputs": ["Block_B"],   // 用户选择的输入节点
  "outputs": ["Block_D"],  // 用户选择的输出节点
  "workspace_id": "workspace_123"
}
```

#### 8.1.3 实际执行示例

```
当 API 被调用时的执行流程：

外部调用：
POST /execute_workflow/api_id
{
  "Block_B": "用户输入的文本内容"
}
        ▼
┌──────────────────────────────────────────┐
│            后端执行流程                   │
│                                          │
│  1. 接收输入数据填充到 Block B           │
│           ▼                              │
│  2. 执行 Edge 2: Block C → Block B       │
│     (可能是编辑或处理操作)                │
│           ▼                              │
│  3. 执行 Edge 3: Block B + C → Block D   │
│     (生成或合并操作)                      │
│           ▼                              │
│  4. 返回 Block D 的内容作为输出          │
└──────────────────────────────────────────┘
        ▼
返回结果：
{
  "Block_D": "处理后的结构化数据"
}
```

### 8.2 输入输出配置

#### 8.2.1 节点选择规则
- **输入节点**：只能选择文本或结构化数据类型的节点
- **输出节点**：只能选择文本或结构化数据类型的节点  
- 文件和网页节点不能直接作为API的输入输出
- 用户需要手动选择，系统不会自动预选

#### 8.2.2 选择建议
- **输入选择**：选择工作流的起始数据节点
- **输出选择**：选择工作流的最终结果节点
- **数量建议**：通常选择1-3个输入节点，1-2个输出节点

### 8.3 服务管理

部署成功后，系统会自动生成：
- **API ID**：唯一标识符，用于调用API
- **API Key**：安全认证密钥
- **端点地址**：完整的API调用地址

所有已部署的服务都会保存在用户的服务列表中，支持：
- 查看服务详情和调用方式
- 删除不再需要的服务
- 重新部署更新后的工作流

## 9. 使用建议

### 9.1 组的设计原则
- **功能相关性**：将执行相似功能的节点组织在一起
- **合理大小**：建议每组包含 3-8 个节点，便于管理
- **清晰命名**：使用描述性的组名，如"用户数据验证"、"报告生成"

### 9.2 颜色使用建议
- **功能分类**：同类功能的组使用相同颜色
- **优先级标识**：重要流程使用醒目颜色（红色、橙色）
- **状态标识**：开发中用蓝色，已完成用绿色

### 9.3 部署最佳实践
- **测试先行**：部署前务必进行 Test Run
- **输入输出优化**：选择最关键的节点作为输入输出
- **文档记录**：为每个已部署的服务添加使用说明

### 9.4 团队协作建议
- **职责分工**：不同组分配给不同团队成员
- **版本管理**：重要修改前先备份现有配置
- **接口约定**：团队内统一API命名和参数规范

## 10. 功能扩展规划

### 10.1 近期功能增强
- **组模板系统**：保存和复用常用的组配置
- **批量操作**：支持同时操作多个组
- **快捷键支持**：提升操作效率
- **搜索功能**：在大型工作流中快速定位组

### 10.2 长期发展方向
- **嵌套组支持**：组内可以包含子组，支持更复杂的层级结构
- **AI智能建议**：基于节点类型和连接关系，智能建议分组
- **版本管理**：支持组配置的版本历史和回滚
- **性能监控**：提供组执行性能的分析和优化建议

## 11. 核心机制总结

### 11.1 提交机制的关键规则

```
┌─────────────────────────────────────────────────────────────────┐
│                     GroupNode 提交机制核心规则                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  规则1: 只提交组内的工作节点                                    │
│  ──────────────────────────                                    │
│  ✅ 组内节点 → 会被提交执行                                     │
│  ❌ 组外节点 → 不会被提交（即使有连接）                          │
│                                                                 │
│  规则2: 处理步骤的组内关联性验证                                │
│  ─────────────────────────────────                             │
│  ✅ 输入和输出都有组内节点 → 会被提交                           │
│  ✅ 所有输入在组内且输出无组内节点 → 会被提交                   │
│  ✅ 输入无组内节点且所有输出在组内 → 会被提交                   │
│  ❌ 输入输出都无组内节点 → 不会被提交                           │
│                                                                 │
│  规则3: 提交的是完整的、可独立运行的工作流                       │
│  ──────────────────────────────────────                       │
│  • 包含所有必要的节点和处理步骤                                 │
│  • 不依赖组外的任何资源                                         │
│  • 可以独立执行并产生结果                                       │
│                                                                 │
│  规则4: API部署时的特殊限制                                     │
│  ──────────────────────────                                    │
│  • 只能选择文本或结构化数据节点作为输入输出                     │
│  • 文件和网页节点不能直接作为API接口                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 11.2 数据流转示意

```
用户界面中的组                   实际提交执行的工作流
─────────────                   ──────────────

Group Node                      完整的处理链路：
├── 节点A ─┐                    节点A → 处理1 → 节点B
├── 节点B ─┼─ 处理1 ─►          节点C → 处理2 → 节点D
├── 节点C ─┘                    
└── 节点D ─── 处理2 ─►          被忽略的连接：
                                外部→节点A（跨边界，不提交）
外部连接：                       节点D→外部（跨边界，不提交）
外部节点 ───► 预处理 ───► 节点A   
                                结果：自包含的工作流
节点D ───► 后处理 ───► 外部节点   
```

## 12. 总结

GroupNode 是一个强大的工作流组织工具，它将复杂的节点关系转化为清晰的逻辑单元。通过直观的可视化设计和便捷的部署功能，用户可以快速构建、测试和发布自己的工作流服务。

### 核心优势：
- **可视化管理**：所见即所得的组管理界面
- **灵活部署**：支持 API 和聊天机器人两种部署方式
- **智能执行**：自动识别和处理节点依赖关系
- **用户友好**：简单的拖拽操作，强大的功能支持

### 实用价值：
- **提升效率**：将复杂工作流模块化，便于管理和复用
- **降低门槛**：非技术人员也能快速创建和部署工作流服务
- **促进协作**：支持团队分工和模板共享
- **扩展性强**：为未来更多功能的添加预留了空间

GroupNode 让工作流管理变得简单、高效、可扩展，是构建智能化业务流程的重要工具。