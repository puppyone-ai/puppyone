# Design: ETL模块持久化和ID类型统一

## Context

当前ETL模块设计为轻量级内存队列,适合MVP阶段快速开发。随着功能完善,需要:
1. 与项目整体ID规范保持一致(int类型)
2. 提供可靠的任务历史记录和状态查询
3. 支持将ETL处理结果集成到Table知识库中

背景约束:
- 项目已有Supabase基础设施和Repository模式
- `etl_task` 表结构已在数据库中定义
- 需保持异步队列的高性能特性

## Goals / Non-Goals

### Goals
- ID类型统一为 int/bigint,与项目标准一致
- 任务状态持久化到Supabase,提供可靠存储
- 提供JSON挂载接口,简化ETL结果到Table的集成流程
- 保持现有异步队列的性能优势

### Non-Goals
- 不引入消息队列(如Redis/RabbitMQ),保持简单
- 不实现任务重试机制(可在后续迭代中添加)
- 不修改现有的MineRU和LLM处理逻辑

## Decisions

### Decision 1: 双存储策略(内存 + Supabase)

**选择**: 任务状态同时保存在内存(`ETLQueue.tasks`)和Supabase中,内存作为热数据,数据库作为冷存储。

**理由**:
- 保持队列高性能:内存访问延迟低,适合高频状态查询
- 数据持久化:数据库提供可靠存储,防止服务重启丢失数据
- 减少数据库写入:中间状态只更新内存,完成/失败才写数据库

**替代方案**:
- 纯数据库存储:每次状态更新都写数据库,会显著增加延迟
- 纯内存存储:服务重启丢失数据,不可接受

### Decision 2: task_id 生成策略

**选择**: 使用数据库自增ID作为 task_id(bigint)

**理由**:
- 与项目其他表ID生成方式一致
- 简化逻辑,避免UUID字符串处理
- bigint范围足够大(9223372036854775807)

**替代方案**:
- UUID: 字符串类型,不符合项目规范,且占用更多存储

### Decision 3: 中间状态更新策略

**选择**: 任务创建和完成/失败时写数据库,中间状态(mineru_parsing、llm_processing)只更新内存

**理由**:
- 减少数据库写入频率,提升性能
- 中间状态变化快,写数据库价值低
- 出错时仍会更新数据库,不会丢失错误信息

**替代方案**:
- 每次状态更新都写数据库:写入频繁,性能影响大
- 只在完成时写数据库:服务崩溃可能丢失正在处理的任务状态

### Decision 4: JSON挂载接口设计

**选择**: 新增独立的挂载接口 `POST /api/v1/etl/tasks/{task_id}/mount`,由用户主动触发

**理由**:
- 解耦:ETL处理和Table集成分离,提升灵活性
- 用户控制:用户可选择是否挂载、挂载到哪个路径
- 幂等性:可重复调用挂载接口

**替代方案**:
- 自动挂载:ETL完成后自动挂载,缺乏灵活性,且需要在任务创建时提供table_id和json_path

## Risks / Trade-offs

### Risk 1: 内存与数据库数据不一致

**场景**: 服务崩溃时,内存中的中间状态未同步到数据库

**缓解**:
- 任务失败时立即写数据库
- 服务启动时可选择性恢复pending状态的任务(后续迭代)

### Risk 2: Breaking Change影响现有客户端

**场景**: API字段类型变更可能导致现有客户端报错

**缓解**:
- 当前ETL模块为新功能,客户端较少
- 提供明确的迁移文档

### Trade-off: 双存储增加代码复杂度

**权衡**: 为了性能和可靠性,接受适度的代码复杂度增加

## Migration Plan

### Phase 1: 实现持久化层
1. 创建 `ETLTaskRepositorySupabase` 类
2. 更新 `ETLTask` 模型,ID字段改为int
3. 集成到 `ETLQueue` 和 `ETLService`

### Phase 2: 更新API层
1. 更新 `router.py` 和 `schemas.py`,ID类型改为int
2. 新增JSON挂载接口
3. 更新单元测试

### Phase 3: 测试和部署
1. 集成测试:验证任务创建、查询、挂载流程
2. 回归测试:确保现有ETL流程正常
3. 部署并通知客户端更新

### Rollback Plan
如发现严重问题,可临时回退到内存存储,数据库记录保留供后续分析。

## Open Questions

1. **是否需要在启动时恢复未完成任务?** 
   - 初步建议:暂不实现,后续根据需求添加
2. **挂载时如何处理重复key?** 
   - 建议:依赖 `TableService.create_context_data()` 的现有逻辑,抛出异常
3. **是否需要支持批量挂载?**
   - 初步建议:暂不支持,一次挂载一个任务

